== GOALS for Wave Game ==
[] read through entire rocket program and make sure I understand EVERYTHING about it.
[] reconfigure the repo as I like
    [] rename "Size" to something that makes more sense, like "Location" or "Area".
        but it's not really an area, as it's just a vector (2 data points)
        so size does make sense, but it's too vague.
[] make rocket its own repository
User Input
    [done] Keyboard
    [] Controller
        [done] joystick
        [done] buttons
        [done] make sure all controller actions are processed in each frame, not just one.
            Yup, for each poll_iter, perfect.
        [] decrease the dead-zone size for more accuracy
            OR keep it, but make it a better equation
            OR make it take into account both axes when figuring out the threshold.
        [] register new controllers when they're plugged in after the game starts.
Dot Physics
    [] change angle_radians to "turns", which I like better for angles.
        or "angle_turns"
    [done] Fix Vector to have two vectors? (see TODO in vector.rs).
        Maybe stop using "vector" entirely, and put it all straight on Player.
        [done] add speed to Player
        [done] use Player speed to ramp stuff up!
        [done] match player movement to joystick
    [] change all occurrences of PI to use TAU instead
    [] Acceleration
        [] change the up button so that it is acceleration instead of
           a constant speed boost
        [] change the gun scatter so that it's a functions of the
           ship's acceleration or speed? Not sure which yet.
    [done] Rotate
        [done] More like, do exactly what the joystick does
        [done] get keyboard working for this, too
Rings
    [done] make circle grow out of player
    [done] change circle colour depending on which button was pressed
    [] change circle to be an "arc", which is a polygon.
        Needs to be a list of arc sections that wrap around 0 properly.
        [done] draw a polygon
            [done] draw vertices of a polygon
            [done] draw it for real
                [done] convert from Point to vec2d
                [done] make polygon
        [done] limit firing rate to one per second
        [done] fix firing rate so the first shot happens.
        [nope] draw 2 layers of polygon
        [done] draw a pretend circle
            takes in two angles, and draws between them
            draws forward from one to the other (even if 0 gets in the way)
            [done] draw it as thick lines instead of polygons
            [done] thicken the lines.
    [] make rings destroy enemies when touching.
        [nope] Treat them as a series of rectangles
            [done] Make the ring thickness a property of the wave
            [done] and the colour
            [nope] make a rectangle hitbox type
                Instead, treat the arc like an arc
        [] make arc - to - circle collision detection
    [done] remove old bullet system
    [] make the trail from the character, each dot in it have a velocity opposite of the character.
        It would be very satisfying if these interact with other objects or eachother.
        Giving them some randomness could be pretty nice as well.
Collisions being detected between objects
    NOT AABB, but all rectangular bounding boxes
    Some resources:
        http://www.gdcvault.com/play/1022194/Physics-for-Game-Programmers-Robust
        Bonus points if it's integer only
            but the we have to choose between having nice 0 to 1 floats or 0-? integers
    [] do basic intersection detection for some basic types
        [done] point in circle
        [done] point in arc
            http://stackoverflow.com/questions/6307114/android-2d-arc-collision-detection
                may not work 100% because of the case where the angle is TAU/2.
                [nope] angle < TAU/2
                    use the method above
                [nope] angle = TAU/2
                    check to-the-right of a line made through the circle
                [nope] angle > TAU/2
                    use the 1st method, but invert the check
                    (so we check if it is NOT within the triangle)
                [] OR we can simplify it!!!! by checking "to the right" of lines.
                lines A and B go from circle origin out, angle distance apart
                if angle <= TAU/2
                    inside if left of A AND right of B
                if angle > TAU/2
                    inside if left of A OR right of B
        [] circle in arc
            http://gamedev.stackexchange.com/a/7737
                This is circle in polygon (convex OR concave)
            [] distance from point to arc.
                If either of the following 3 are true:
                    - point within arc that is 2*d thicker
                    - point within d of left line segment
                    - point within d of right line segment
                    If the arc angle is 0, both lines will be the same and it should work.
                    If the width of the arc is 1, both lines will be dots, and that's fine.
        [done] circle in circle
        [done] point in convex polygon
        [] circle in rectangle
            [] distance to line segment
            [] circle in rectangle
        [done] move tests to a "tests" folder.
            This is apparently a standard thing to do, and will reduce warnings when running tests.
            [done] move tests into mod test {} instead.
        [] make tests where two shapes run at each other,
           and change colour when they are intersecting
           [done] first, set up multiple binaries for cargo
           [] capture mouse movement
           [] draw a dot where the mouse cursor points
           [] make a way to rig entities to do things when stuff happens
               Make/use FRP?
               Callbacks?
                Tricky to do with lifetimes/Copy-ing, etc.
               Make a broadcast/listen system?
               Hard-code it?
                Yup. A new type for each behaviour for now.
                [done] do it
                    [nope] Have a default implementation in the trait to make things easier.
                [] replace the bullets with the new "entities".
               Maybe I can have a const that is looked up by enum, so it's all static?
                Is this really any different than hand-coding it?
               I want to be able to add characteristics at runtime.
                Example?
               [nope] Use Components!
                  http://gameprogrammingpatterns.com/component.html
                  Maybe this isn't a good fit, as our codebase isn't big enough...
                  Though this may be worth looking into:
                    https://github.com/HeroesGrave/ecs-rs/blob/master/doc/tutorial.md
                  We will not use components.
                    Instead we will use traits.
                [done] change "Entity" to be a trait instead?
                    this trait is useful for iterators.
                        so we can combine all our vectors and treat them the same
                [done] What if I did components completely through traits?
                    Whenever I need a new behavior, I would make a new trait?
                    HOW it implements a trait would give it behaviour.
           [done] figure out how to have a hitbox for each element,
              but still have that element be cloneable.
                The problem is that Collidable could have any size.
                [done] try using an enum instead of a trait?????????
                    that way all hitboxes have the same size.
                [nope] try doing a manual clone?
           [done] make the new objects have a velocity
           [done] make entity change colours when it's collided.
           [done] fix collision when there are multiple entities.
           [] figure out a way to separate "Game" from level.
             Game should be a storage container for all the stuff in a level.
             Game should contain a Level (trait) that holds all the state transitions.
                and the current state.
             Is this World?
             Main --[Inputs, Render, Update]--> Game
             Game --[Render, Advance/Update (particles, waves, player), Shooting, trail, spawn enemies, collision handling, logic, spawning]--> World
                There's a ton of self.world.enemies, which is BAD.
             World [renders all the things, stores all the things]
             [] have Game store all the elements, and have world (renamed level?)
                control the logic.
                    Including physics? Probably.
                Should they be side-by-side? Or one controlled by the other?
                    For now, game will store world (renamed level)
             [done] make a way to tell main.rs which level to run via command line.
             [done] make that work
                [done] make Game take one of these levels
                [done] make main pass in the level to Game
             [done] remove the other binaries in cargo.toml.
             [] make a level trait
             [] change test_collision.rs to simply call main with Level_0.
                If the previous thing works, don't do this
                and instead get rid of multiple binaries
                and do `cargo run level_0`
        [] move each piece in collisions/mod.rs into its own file.
            Each file should have an associated test file.
                Or have the tests in the same file ???
        [] move Point to be with the rest of the collision stuff?
            or is it more general?
            either way, it doesn't belong in drawing if it's used for more stuff.
                the dependencies should not have cycles! (ideally...)
    [] Make a Graham Scan algorithm to produce 2D convex hulls for lists of points
        https://en.wikipedia.org/wiki/Graham_scan
Draw images to the screen
    [] with transparency in backgrounds
    [] make an animation system
        May not be necessary for game #1.
        [] make skeletons
        [] make them adjustable
        [] allow the setting of keypoints
        [] allow tweening
Lasers
    Death
    Set up targets to shoot
Multiple Players
Resetting the level
Builds
    [done] Set up TravisCI to build the project on stable, beta, and nightly each night.
    [] See if it's possible for different versions of major libraries in use, too.
    [] set up multiple binaries in cargo, so we can test different levels
        So we can make test levels dedicated to things like collisions.
        OR maybe there's a better way?
            I just want to be able to give one command to build and run a certain level.
Tools
    [] Make functions to allow the use of hsl and other non-RGB colour types.
        Use these? https://github.com/servo/rust-css/blob/master/color.rs
        Maybe build these into drawing::color if it's not already there?
    [] Make a VERY EASY way to show a text overlay of things as they happen.
        A scrolling list, like a terminal where messages are popping up.

Explanation of Rust's module system:
    https://gist.github.com/DanielKeep/470f4e114d28cd0c8d43
    modules and files:
        // some file
        mod stuff {
            pub fn bla ...
        }

        ^^^ is equivalent to vvv

        //src/lib.rs
        mod stuff;

        //src/stuff.rs
        pub fn bla ...
    modules have their own symbol tables (scope):
        pub fn one() {}

        mod a {
            use one;  // doesn't work without this line
            fn two() { one() }

            //or do it this way:
            fn three() { ::one() }
        }
    The supreme example:
        pub fn f1() {}

        mod a {
            use f1;     // use, by default, is relative to root module of the crate
            use b::f4;  // use cannot begin with "::"
                        // use self:: is relative to the current module
                        // use super:: is relative to the parent of the current module
            pub fn f2() { f1() }
            fn f3() { f4() }
        }

        mod b {
            pub fn f4() { ::f1() }  // relative to root module of crate (because of "::" at start)
            fn f5() { super::f1() } // relative to parent of current module (because of "super::")
            fn f6() { ::a::f2() }
            fn f7() { super::a::f2() }
            fn f8() { self::f4() }  // relative to current module (because of "self::")
            fn f9() { self::f5() }
        }

        fn f10() {
            a::f2();          // non-use are relative to the current module
            self::a::f2();
            // a::f3();       // error: function `f3` is private
            b::f4();
            // b::f5();       // error: function `f5` is private
        }

        fn main() {}
